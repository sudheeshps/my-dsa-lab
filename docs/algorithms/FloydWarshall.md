# Floyd-Warshall Algorithm

## Introduction

The Floyd-Warshall algorithm is an all-pairs shortest path algorithm, meaning it finds the shortest paths between all pairs of vertices in a weighted graph. It can handle both positive and negative edge weights, but it cannot handle negative cycles. If a negative cycle is detected, it indicates that shortest paths involving that cycle are undefined.

---

## History

The algorithm was published by **Robert Floyd** in 1962 and independently by **Stephen Warshall** in 1962. It is also related to earlier work by **Bernard Roy** in 1959 and **Peter Ingerman** in 1962. It is a classic example of dynamic programming.

---

## Behaviour of the Floyd-Warshall Algorithm

The Floyd-Warshall algorithm works by iteratively improving an estimate of the shortest path between two vertices. It considers all possible intermediate vertices `k` for paths between every pair of vertices `(i, j)`. The algorithm proceeds in `V` phases, where `V` is the number of vertices.

In each phase `k` (from `0` to `V-1`), the algorithm considers paths that are allowed to use vertices `0` through `k` as intermediate points. It updates the shortest distance between `i` and `j` if a path `i -> k -> j` is shorter than the current known shortest path `i -> j`.

The core recurrence relation is:
`dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`

After `V` iterations, the `dist[i][j]` matrix will contain the shortest path distances between all pairs of vertices. Negative cycles are detected if, after all iterations, any `dist[i][i]` (distance from a vertex to itself) is negative.

---

## Algorithm Complexity

-   **Time Complexity**: `O(V^3)`, where `V` is the number of vertices. This is because the algorithm uses three nested loops, each iterating `V` times.
-   **Space Complexity**: `O(V^2)` to store the distance matrix and `O(V^2)` to store the predecessor matrix for path reconstruction.

---

## Comparison

-   **Dijkstra's Algorithm**: Dijkstra's is a single-source shortest path algorithm that is faster for sparse graphs (`O(E log V)`). To find all-pairs shortest paths using Dijkstra's, you would run it `V` times, resulting in `O(V * E log V)`. Floyd-Warshall is better for dense graphs or when negative weights are present (without negative cycles).

-   **Bellman-Ford Algorithm**: Bellman-Ford is also a single-source shortest path algorithm (`O(V * E)`) that can handle negative weights and detect negative cycles. Running Bellman-Ford `V` times for all-pairs shortest paths would be `O(V^2 * E)`, which is generally worse than Floyd-Warshall for dense graphs.

---

## How the Algorithm is Implemented

This implementation uses a 2D array (or nested `HashMap`s for sparse graphs) to store the shortest distances between all pairs of vertices. It initializes the distances based on the direct edge weights and then iteratively updates them using the dynamic programming approach described above. A separate 2D array (or `HashMap`) is used to store predecessors for path reconstruction.

---

## Known Applications

-   **Transitive Closure**: Finding all reachable pairs in a graph.
-   **Routing**: In networks where all-pairs shortest paths are needed, such as in some autonomous systems.
-   **Matrix Inversion**: Can be adapted to solve matrix inversion problems.
-   **Computational Geometry**: For finding all-pairs shortest paths in certain geometric graphs.

---

## API Documentation

### `public static <T> Map<Graph.Vertex<T>, Map<Graph.Vertex<T>, Double>> findShortestPaths(Graph<T> graph)`

Finds the shortest paths between all pairs of vertices in a `graph` using the Floyd-Warshall algorithm.

-   **Parameters:**
    -   `graph`: The `Graph<T>` on which to perform the search. The graph should be weighted.
-   **Returns:**
    -   A `Map<Graph.Vertex<T>, Map<Graph.Vertex<T>, Double>>` where the outer map's keys are source vertices, inner map's keys are destination vertices, and values are their shortest distances.
    -   Returns `null` if a negative cycle is detected.

### `public static <T> List<Graph.Vertex<T>> reconstructPath(Graph.Vertex<T> source, Graph.Vertex<T> destination, Map<Graph.Vertex<T>, Map<Graph.Vertex<T>, Graph.Vertex<T>>> predecessors)`

Reconstructs the shortest path from `source` to `destination` using the `predecessors` map generated by `findShortestPaths`.

-   **Parameters:**
    -   `source`: The starting vertex.
    -   `destination`: The ending vertex.
    -   `predecessors`: A map where `predecessors.get(i).get(j)` gives the predecessor of `j` on a shortest path from `i`.
-   **Returns:**
    -   A `List<Graph.Vertex<T>>` representing the shortest path.
    -   Returns `null` if no path exists or if `predecessors` is `null`.
