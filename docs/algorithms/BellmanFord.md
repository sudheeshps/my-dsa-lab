# Bellman-Ford Algorithm

## Introduction

The Bellman-Ford algorithm is a single-source shortest path algorithm that finds the shortest paths from a single source vertex to all other vertices in a weighted digraph (directed graph). It is particularly useful because it can handle graphs where edge weights can be negative, unlike Dijkstra's algorithm, which assumes non-negative edge weights. However, if the graph contains a negative cycle reachable from the source, the Bellman-Ford algorithm can detect it, as a shortest path would not exist in such a scenario.

---

## History

The algorithm was developed by **Richard Bellman** in 1958 and independently by **Lester Ford Jr.** in 1956. It is a foundational algorithm in graph theory and computer science, often taught alongside Dijkstra's algorithm to highlight the differences in their applicability and performance.

---

## Behaviour of the Bellman-Ford Algorithm

The Bellman-Ford algorithm works by iteratively relaxing edges. Relaxation is a process where the algorithm attempts to improve an estimate of the shortest path to a vertex by checking if a shorter path can be found through an adjacent vertex. The algorithm performs `V-1` passes over all the edges in the graph, where `V` is the number of vertices.

In each pass, for every edge `(u, v)` with weight `w`, if the distance to `u` plus the weight of the edge `(u, v)` is less than the current distance to `v`, then the distance to `v` is updated. After `V-1` passes, the algorithm guarantees that all shortest paths have been found, assuming no negative cycles.

To detect negative cycles, a `V`-th pass is performed. If any distance can still be relaxed in this `V`-th pass, it indicates the presence of a negative cycle reachable from the source vertex.

---

## Algorithm Complexity

-   **Time Complexity**: `O(V * E)`, where `V` is the number of vertices and `E` is the number of edges. This is because the algorithm iterates `V-1` times (or `V` times for negative cycle detection), and in each iteration, it processes all `E` edges.
-   **Space Complexity**: `O(V)` to store the distance estimates for each vertex and `O(V)` to store the predecessor for path reconstruction.

---

## Comparison

-   **Dijkstra's Algorithm**: Dijkstra's algorithm is generally faster (`O(E + V log V)` with a Fibonacci heap) but cannot handle negative edge weights. Bellman-Ford is slower but more versatile as it can handle negative weights and detect negative cycles.

-   **Floyd-Warshall Algorithm**: Floyd-Warshall is an all-pairs shortest path algorithm (`O(V^3)`), meaning it finds the shortest paths between all pairs of vertices. Bellman-Ford is a single-source shortest path algorithm. While Floyd-Warshall can also handle negative weights and detect negative cycles, it is typically used when all-pairs shortest paths are required.

---

## How the Algorithm is Implemented

This implementation of Bellman-Ford uses a `HashMap` to store the shortest distance from the source to each vertex and another `HashMap` to store the predecessor of each vertex for path reconstruction. The algorithm iterates `V-1` times, and in each iteration, it goes through all edges to perform relaxation. A final `V`-th iteration is used to check for negative cycles.

---

## Known Applications

-   **Routing Protocols**: Used in some routing protocols, such as the Distance Vector Routing Protocol (e.g., RIP), where routers exchange information about distances to destinations.
-   **Arbitrage Detection**: In financial modeling, it can be used to detect arbitrage opportunities in currency exchange markets, where a series of trades might result in a profit due to small discrepancies in exchange rates (which can be modeled as negative cycles).
-   **Network Flow**: As a subroutine in more complex network flow algorithms.

---

## API Documentation

### `public static <T> Map<Graph.Vertex<T>, Double> findShortestPaths(Graph<T> graph, Graph.Vertex<T> source)`

Finds the shortest paths from a `source` vertex to all other vertices in a `graph` using the Bellman-Ford algorithm.

-   **Parameters:**
    -   `graph`: The `Graph<T>` on which to perform the search. The graph should be weighted.
    -   `source`: The `Graph.Vertex<T>` representing the starting point for the paths.
-   **Returns:**
    -   A `Map<Graph.Vertex<T>, Double>` where keys are vertices and values are their shortest distances from the `source`.
    -   Returns `null` if a negative cycle is detected.

### `public static <T> List<Graph.Vertex<T>> reconstructPath(Graph.Vertex<T> source, Graph.Vertex<T> destination, Map<Graph.Vertex<T>, Graph.Vertex<T>> predecessors)`

Reconstructs the shortest path from `source` to `destination` using the `predecessors` map generated by `findShortestPaths`.

-   **Parameters:**
    -   `source`: The starting vertex.
    -   `destination`: The ending vertex.
    -   `predecessors`: A map where each vertex maps to its predecessor in the shortest path.
-   **Returns:**
    -   A `List<Graph.Vertex<T>>` representing the shortest path.
    -   Returns `null` if no path exists or if `predecessors` is `null`.
