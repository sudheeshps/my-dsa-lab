# Dijkstra's Shortest Path Algorithm

## Introduction

Dijkstra's algorithm is a popular and efficient algorithm for finding the shortest paths between nodes in a graph. It is a single-source shortest path algorithm, meaning it finds the shortest path from a single starting node (the "source") to all other nodes in the graph. A key characteristic of Dijkstra's algorithm is that it only works with graphs where all edge weights are non-negative.

---

## History

Dijkstra's algorithm was conceived by **Edsger W. Dijkstra** in 1956 and published three years later. Dijkstra, a Dutch computer scientist, developed the algorithm to demonstrate the capabilities of a new computer, the ARMAC, by solving a problem that could be easily explained to non-computer scientists: finding the shortest route between two cities.

---

## Behaviour of Dijkstra's Algorithm

The algorithm operates by maintaining a set of visited nodes and a set of unvisited nodes. It iteratively selects the unvisited node with the smallest known distance from the source and marks it as visited. Then, it updates the distances of all its unvisited neighbors. This process continues until all nodes have been visited or the shortest path to the target node has been determined.

At each step, Dijkstra's algorithm:

1.  Initializes distances: Sets the distance to the source node as 0 and to all other nodes as infinity.
2.  Maintains a priority queue: Stores unvisited nodes, prioritized by their current shortest distance from the source.
3.  Extracts minimum: Repeatedly extracts the node `u` with the smallest distance from the priority queue.
4.  Relaxes edges: For each neighbor `v` of `u`, if the path through `u` to `v` is shorter than the current known shortest path to `v`, it updates `v`'s distance and its predecessor.

---

## Algorithm Complexity

-   **Time Complexity**: The time complexity of Dijkstra's algorithm depends on the data structure used for the priority queue:
    -   With a **binary heap**: `O(E log V)`, where `V` is the number of vertices and `E` is the number of edges. This is generally efficient for sparse graphs.
    -   With a **Fibonacci heap**: `O(E + V log V)`. This is asymptotically faster for dense graphs but has higher constant factors, making binary heaps often preferred in practice.
-   **Space Complexity**: `O(V + E)` to store the graph, distances, and predecessors.

---

## Comparison

-   **Bellman-Ford Algorithm**: Unlike Dijkstra's, Bellman-Ford can handle graphs with negative edge weights and detect negative cycles. However, it is generally slower, with a time complexity of `O(V * E)`.

-   **A* Search Algorithm**: A* is an extension of Dijkstra's that uses a heuristic function to guide its search, making it more efficient for pathfinding in many practical scenarios, especially in large graphs where a target destination is known. A* is also restricted to non-negative edge weights.

-   **Breadth-First Search (BFS)**: BFS finds the shortest path in unweighted graphs (or graphs where all edge weights are equal). Dijkstra's is a generalization that works for weighted graphs.

---

## How the Algorithm is Implemented

This implementation of Dijkstra's algorithm uses a `PriorityQueue` to efficiently retrieve the vertex with the smallest distance. It also uses `HashMap`s to store the current shortest distance to each vertex (`distances`) and the predecessor of each vertex in the shortest path (`predecessors`).

---

## Known Applications

-   **Network Routing**: Used in IP routing protocols (e.g., OSPF) to find the shortest path for data packets.
-   **GPS Navigation**: Finding the shortest route between two locations on a map.
-   **Transportation Logistics**: Optimizing delivery routes.
-   **Image Processing**: Finding optimal paths for image segmentation.

---

## API Documentation

### `public static <T> Map<Graph.Vertex<T>, Double> findShortestPaths(Graph<T> graph, Graph.Vertex<T> source)`

Finds the shortest paths from a `source` vertex to all other vertices in a `graph` using Dijkstra's algorithm.

-   **Parameters:**
    -   `graph`: The `Graph<T>` on which to perform the search. The graph should be weighted with non-negative edge weights.
    -   `source`: The `Graph.Vertex<T>` representing the starting point for the paths.
-   **Returns:**
    -   A `Map<Graph.Vertex<T>, Double>` where keys are vertices and values are their shortest distances from the `source`.

### `public static <T> List<Graph.Vertex<T>> reconstructPath(Graph.Vertex<T> source, Graph.Vertex<T> destination, Map<Graph.Vertex<T>, Graph.Vertex<T>> predecessors)`

Reconstructs the shortest path from `source` to `destination` using the `predecessors` map generated by `findShortestPaths`.

-   **Parameters:**
    -   `source`: The starting vertex.
    -   `destination`: The ending vertex.
    -   `predecessors`: A map where each vertex maps to its predecessor in the shortest path.
-   **Returns:**
    -   A `List<Graph.Vertex<T>>` representing the shortest path.
    -   Returns `null` if no path exists or if `predecessors` is `null`.
